library(tidyverse)
library(stringr)

## 什么是正则表达式
我们在word文档或者excel中，经常使用查找和替换, 然而有些情况，word是解决不了的，比如
- 条件搜索
  - 统计文中，前面有 “`data`”, “`computer`” or “`statistical`” 的 “`analysis`”，这个单词的个数
  - 找出文中重复的单词，比如“we love love you”
- 拼写检查
  - 电话号码（邮件，密码等）是否正确格式
  - 日期书写的规范与统一
- 提取信息
  - 提取文本特定位置的数据
- 文本挖掘
  - 非结构化的提取成结构化

- 这个时候就需要用到**正则表达式**（`Regular Expression`），这一强大、便捷、高效的文本处理工具。那么，什么是正则表达式呢？简单点说，正则表达式是处理字符串的。

- 复杂点说，正则表达式描述了一种字符串匹配的模式（`pattern`），通常被用来检索、替换那些符合某个模式(规则)的文本。这种固定的格式的文本，生活中常见的有电话号码、网络地址、邮件地址和日期格式等等。

- 正则表达式并不是R语言特有的，事实上，几乎所有程序语言都支持正则表达式 (e.g. Perl, Python, Java, Ruby, etc).

- R 语言中很多函数都需要使用正则表达式，然而正则表达式不太好学。幸运的是，大神`Hadley Wickham`开发的`stringr`包让正则表达式简单易懂

## 字符串基础
### 1 字符串长度`str_length()` 
- 获取字符串的长度,
  - 对于字符串向量，也适用
  - 数据框里配合`dplyr`函数，同样很方便

str_length("R for data science")
str_length(c("a", "R for data science", NA))

# 数据框里配合dplyr函数
data.frame(
  x = c("a", "R for data science", NA)
) %>% 
  mutate(y = str_length(x))

### 2 字符串组合`str_c()` 
- 把字符串拼接在一起
  - 可以设置中间的间隔——分隔符
  - 可以用在数据框中
  - `collapse`选项，是先组合，然后加上分隔符转换成单个字符串
  - `sep`是对组合设置分隔符

str_c("x", "y")
str_c("x", "y", sep=", ")
str_c(c("x", "y", "z"), sep=", ")
# 说明c("x", "y", "z")代表一个元素
str_c(c("x", "y", "z"), c("x", "y", "z"),  sep=", ")

# 用在数据框
data.frame(
  x = c("I", "love", "you"),
  y = c("you", "like", "me")
) %>% 
  mutate(z = str_c(x, y, sep=" | "))

# collapse选项, 先组合，后转换成单个字符串
str_c(c("x","y","z"), c("a","b","c"), sep=" | ")
str_c(c("x","y","z"), c("a","b","c"), collapse=" | ")

### 3 字符串取子集`str_sub()`
  - 截取字符串的一部分，需要指定截取的开始位置和结束位置
  - 开始位置和结束位置如果是负整数，就表示位置是从后往前数
  - 也可以进行赋值，如果该位置上有字符，就用新的字符替换旧的字符

x <- c("Apple", "Banana", "Pear")
str_sub(x, 2, 3)
str_sub(x, -3, -2)

str_sub(x,1,1)
str_sub(x, 1, 1) <- "Q"
x

## 使用正则表达式进行模式匹配
### 1 基础匹配`str_view()`
- 查看`string`是否匹配`pattern`，如果匹配，就高亮显示
- `.`代表任意字符，表达本身则需转义字符`\\.`
### 2 锚点
- `^a` a是字符串的开始进行匹配
- `a$` a是字符串的结尾进行匹配
### 3 字符类与字符选项
前面提到，.匹配任意字符，事实上还有很多这种特殊含义的字符：

  - `\d`: matches any digit.
  - `\D`: matches any except digit.
  - `\s`: matches any whitespace (e.g. space, tab, newline).
  - `[abc]`: matches a, b, or c.
  - `[^abc]`: matches anything except a, b, or c.
### 4 重复
- 控制匹配次数
  - `?`: 0 or 1
  - `+`: 1 or more
  - `*`: 0 or more
  
  - `{n}`: exactly n
  - `{n,}`: n or more
  - `{,m}`: at most m
  - `{n,m}`: between n and m
- 默认的情况，`*`,` +` 匹配都是贪婪的，也就是它会尽可能的匹配更多
- 如果想让它不贪婪，而是变得懒惰起来，可以在`*`,` +` 加个`?`

![image.png](attachment:image.png)

x <- c("apple", "banana", "pear")
str_view(string=x, pattern="an")
# 有时候，我们希望在字符a前后都有字符
str_view(x, ".a.")

x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
str_view(x, "^apple$")

# 字符类与字符选项
str_view(c("grey", "gray"), "gr[ea]y")

# 控制匹配次数
x <- "Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "X+")
str_view(x, "C{2,}")
str_view(x, "C{2,3}")

# 控制匹配次数
# 让* + 变得不贪婪
x <- "Roman numerals: MDCCCLXXXVIII"
str_view(x, "CLX+")
str_view(x, "CLX+?")

### 5 分组与回溯引用
- `.` 是匹配任何字符
- `(.)` 将匹配项括起来，它就用了一个名字，叫`\\1`； 如果有两个括号，就叫`\\1`和`\\2`
- `\\1` 表示回溯引用，表示引用`\\1`对于的`(.)`

`(.)\\1`的意思就是，匹配到了字符，后面还希望有个同样的字符

ft <- fruit %>% head(10)
ft

# 我们想看看这些单词里，有哪些字母是重复两次的，比如aa, pp. 
# 如果用上面学的方法
str_view(ft, ".{2}", match=TRUE)
# 发现和我们的预想不一样。
str_view(ft, "(.)\\1", match=TRUE)

## 如果是匹配abab, wcwc
str_view(ft, "(..)\\1", match=TRUE)

## 如果是匹配abba, wccw
str_view(ft, "(.)(.)\\2\\1", match=TRUE)

### 6 大小写敏感
- `(?i)` 匹配元素不区分大小写

df <- tibble::tribble(
  ~tch_id,  ~online_platform,
      105,          "Google",
      106,            "meet",
      107,            "Zoom",
      108,            "zoom",
      109,     "Google Meet",
      112, "Microsoft Teams",
      113,                NA
)
df

# 希望找出线上平台是google和meet的记录，显然Google和google是一个意思，
# 都应该被筛选出
## 方法1 使用stringr::regex()
df %>% 
  filter(
    str_detect(online_platform, regex("google|meet", ignore_case=TRUE))
  )

## 方法2 使用(?i)
df %>% 
  filter(
    str_detect(online_platform, "(?i)google|meet")
  )

## 解决实际问题
### 1 确定一个字符向量是否匹配一种模式
- 实际问题中，想判断是否匹配？可以用到`str_detect()`函数，返回逻辑向量
- 可用在`filter()`函数中，筛选某列符合条件的行
- `stringr::words`包含了牛津字典里常用单词
- `str_detect()` 有一个功能类似的函数`str_count()`，区别在于，后者不是简单地返回是或否，而是返回字符串中匹配的数量

y <- c("apple", "banana", "pear")
str_detect(y, "e")

d <- tibble(x=c("apple","banana","pear"))
d
d %>% mutate(has_e = str_detect(x, "e"))
d %>% dplyr::filter(str_detect(x,"e"))

stringr::words %>% head()

## 统计以t开头的单词
sum(str_detect(words, "^t"))
# 以元音结尾的单词，占比多少？
mean(str_detect(words, "[aeiou]$"))

## 所以这里把逻辑向量强制转换为了数字型
str_detect(words, "^t") %>% head()

# 在数据框里, 看看以x结尾的单词是哪些

tibble(
  word = words
) %>% 
  dplyr::filter(str_detect(word, "x$"))

# str_count() 函数，返回字符串中匹配的数量
x <- c("apple", "banana", "pear")
str_count(x, "a")

tibble(
  word = words
) %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]") # 除了元音字母外的数量
  )

### 2 确定匹配的位置
- 正则表达式不会重叠匹配。比如用`"aba"`去匹配`"abababa"`，肉眼感觉是三次，但正则表达式告诉我们是两次，因为不会重叠匹配
- `str_count()` 统计匹配到的数量
- `str_view_count()` 查看所有匹配到的位置

str_count("abababa", "aba")

str_view_all("abababa", "aba")

### 3 提取匹配的内容
- `str_extract()` 只提取第一个——谁先匹配提取谁
- `str_extract_all()`提取全部匹配到的内容
  - `unnest()`将匹配到的内容分不同行保存, `keep_empty=TRUE`保留无法展开的行
  

colours <- c(
  "red", "orange", "yellow",
  "green", "blue", "purple"
)
colour_match <- str_c(colours, collapse="|")
colour_match1 <- str_c(colours, sep="|")
## 直观的感受下 collapse 和 sep 的区别
colour_match
colour_match1

str_view("abcd", "ab|cd")
str_view("abcd", "[ab][cd]")

more <- "It is hard to erase blue or red ink."
str_extract(more, pattern = colour_match)
str_extract_all(more, pattern = colour_match)

# 取出sentences中，含有有两种和两种颜色以上的句子
more <- sentences[str_count(sentences, colour_match) > 1]
more

tibble(sentence = sentences) %>% 
  filter(str_count(sentence, colour_match) > 1)

# str_extract()提取匹配, 谁先匹配就提取谁
more <- sentences[str_count(sentences, colour_match) > 1]

tibble(x = more) %>% 
  mutate(color = str_extract(x, colour_match))

# str_extract_all()提取全部匹配项
tibble(x = more) %>% 
  mutate(color = str_extract_all(x, colour_match))

tibble(x = more) %>% 
  mutate(color = str_extract_all(x, colour_match)) %>% 
  unnest(color)

### 4 替换匹配内容
 - `str_replace()`  替换首个匹配
 - `str_replace_all()` 替换所有匹配

x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")

### 5 拆分字符串
- 这个和`str_c()`是相反的操作
- `str_split()` `simplify=TRUE`将其转化为数据框
- `n = 2`：这意味着每个原始字符串最多会被分割成两部分。例如，如果有多个冒号和空格，只会取前两个分隔后的部分。

lines <- "I love my country"
lines
str_split(lines, " ")

fields <- c("Name: Hadley", "Country: N: Z", "Age: 35")
fields
fields %>% str_split(": ", n = 2, simplify=TRUE)
fields %>% str_split(": ")
fields %>% str_split(": ", n = 3, simplify=TRUE)

## 进阶部分
带有条件的匹配
### 1 `look ahead`
Windows后面的 `() `是匹配条件，事实上，有四种情形：

- `(?=pattern)` 要求此位置的**后面**必须匹配表达式pattern
- `(?!pattern)` 要求此位置的**后面**不能匹配表达式pattern

### 2 `look behind`
- `(?<=pattern)` 要求此位置的**前面**必须匹配表达式pattern
- `(?<!pattern)` 要求此位置的**前面**不能匹配表达式pattern

# `look ahead`
# 想匹配Windows，同时希望Windows右侧是"95", "98", "NT", "2000"中的一个
win <- c("Windows2000", "Windows", "Windows3.1")
str_view(win, "Windows(?=95|98|NT|2000)")
str_view(win, "Windows(?!95|98|NT|2000)")

## look behind
win <- c("2000Windows", "Windows", "3.1Windows")
str_view(win, "(?<=95|98|NT|2000)Windows")
str_view(win, "(?<!95|98|NT|2000)Windows")

## 案例分析
- `tidyr::extract()`提取匹配到pattern的整个元素，而不是pattern
- `tidyr::extract(x, c(), "pattern")` `c()`将匹配到的元素分成几列的列名，几列与pattern有关，pattern有几个`()`就几列
### 案例1

# 我们希望能提取第二列中的数值，构成新的一列
dt <- tibble(
  x = 1:4,
  y = c("wk 3", "week-1", "7", "w#9")
)
dt

dt %>% 
  mutate(
    z = str_extract(y, "[0-9]"))

### 案例2 

# 提取第二列中的大写字母
df <- data.frame(
  x = seq_along(1:7),
  y = c("2016123456", "20150513", "AB2016123456", "J2017000987", "B2017000987C", "aksdf", "2014")
)
df

df %>% 
  mutate(
    z = str_extract_all(y, "[A-Z]")
  ) %>% 
  tidyr::unnest(z)

### 案例3

# 要求：中英文分开
tb <- tibble(x = c("I我", "love爱", "you你"))
tb
tb %>% 
  tidyr::extract(
    x, c("en", "cn"), "([a-zA-Z]+)([^a-zA-Z]+)",
  remove = FALSE)

### 案例4

# 要求：提取起始数字
df <- tibble(x = c("1-12week", "1-10week", "5-12week"))
df

df %>% extract(
  x, c("start", "end", "cn"), "(\\d+)-(\\d+)(\\D+)",
  remove = FALSE)

### 案例5

# 要求：提取大写字母后的数字
df <- tibble(
 x = c("12W34", "AB2C46", "B217C", "akTs6df", "21WD4")
)
df

df %>% 
  mutate(item = str_extract_all(x, "(?<=[A-Z])[0-9]")) %>% 
  tidyr::unnest(item)

# 提取大写字母后的连续数字
df %>% 
  mutate(
    item = str_extract_all(x, "(?<=[A-Z])\\d+")) %>% 
  tidyr::unnest(item)
# 提取数字前大写字母
df %>% 
  mutate(
    item = str_extract_all(x, "[A-Z](?=[0-9])")) %>% 
  tidyr::unnest(item)

x <- "Roman numerals: MDCCCLXXXVIII"
str_match_all(x,"C?")

str_match_all(x, "CC?")

### 案例6 

# 提取数字并求和
df <- tibble(
  x = c("1234", "B246", "217C", "2357f", "21WD4")
)
df
df %>% 
  mutate(num = str_extract_all(x, "\\d")) %>% 
  unnest(num) %>% 
  mutate_at(vars(num), as.numeric) %>% 
  group_by(x) %>% 
  summarise(sum = sum(num))

### 案例7
- `tibble::deframe()`将数据框或`tibble`转换为键值对

## 文本替换
text <- "Quantum entanglement is a physical phenomenon that occurs when pairs or groups of particles are generated, interact, or share spatial proximity in ways such that the quantum state of each particle cannot be described independently of the state of the others, even when the particles are separated by a large distance."

pairs <-
  tibble::tribble(
    ~item, ~code,
    "Quantum entanglement", "A01",
    "physical phenomenon", "A02",
    "quantum state", "A03",
    "quantum mechanics", "A04"
  ) %>%
  tibble::deframe()
pairs

text %>% str_replace_all(pairs)

### 案例8

# 提取Sichuan Univ后面的学院
df <- tibble::tribble(
  ~No, ~address,
    1, "Sichuan Univ, Coll Chem",
    2, "Sichuan Univ, Coll Elect Engn",
    3, "Sichuan Univ, Dept Phys",
    4, "Sichuan Univ, Coll Life Sci",
    5, "Sichuan Univ, Food Engn",
    6, "Sichuan Univ, Coll Phys",
    7, "Sichuan Univ, Sch Business",
    8, "Wuhan Univ, Mat Sci")
df

df %>% 
  mutate(college = str_extract(address, "(?<=Sichuan Univ, ).*")
        ) %>% 
  tidyr::unnest(college, keep_empty=TRUE)

df %>% 
  mutate(college = str_remove_all(address, ".*, "))

df %>% 
  separate(
    address, 
    into = c("univ", "college"),
    sep = ",",
    remove = FALSE)

df %>% tidyr::extract(
  address, c("univ", "college"), "(Sichuan Univ), (.+)",
  remove=FALSE)
df %>% tidyr::extract(
  address, c("univ", "college"), "(.*), (.+)",
  remove=FALSE)





